from __future__ import annotations

from pathlib import Path
from tempfile import NamedTemporaryFile
from typing import Optional, Sequence, Tuple


def resolve_figure_width(width_arg, global_extent: float) -> float:
    from core.engine import resolve_figure_width as _resolve_figure_width

    return _resolve_figure_width(width_arg, global_extent)


def write_stream_debug_tables(
    output: Path,
    data,
    global_x,
    query_x,
    reference_x,
    query_positions,
    reference_positions,
) -> None:
    from core.engine import write_stream_debug_tables as _write_stream_debug_tables

    _write_stream_debug_tables(
        output,
        data,
        global_x,
        query_x,
        reference_x,
        query_positions,
        reference_positions,
    )


def plot_alignment(
    data,
    global_x,
    query_x,
    reference_x,
    query_positions,
    reference_positions,
    global_extent: float,
    gap_labels,
    width: float,
    height: float,
    dpi: int,
    output: Path,
    tick_interval: int,
    backbone_thickness: float,
    mismatch_line_width: float,
    gap_label_size,
    query_annotations,
    reference_annotations,
    annotation_label_size,
    annotation_thickness: float,
    annotation_alpha: float,
    reference_annotation_color: str,
    query_annotation_color: str,
    annotation_label_jitter: float,
    annotation_max_layers: int,
    annotation_spacing: float,
    x_window: Optional[Tuple[float, float]] = None,
    inversion_regions: Optional[Sequence[dict]] = None,
    feature_regions: Optional[Sequence[dict]] = None,
    *,
    return_metadata: bool = False,
    tight_bbox: bool = True,
    full_canvas_axes: bool = False,
):
    from core.engine import plot_alignment as _plot_alignment

    return _plot_alignment(
        data=data,
        global_x=global_x,
        query_x=query_x,
        reference_x=reference_x,
        query_positions=query_positions,
        reference_positions=reference_positions,
        global_extent=global_extent,
        gap_labels=gap_labels,
        width=width,
        height=height,
        dpi=dpi,
        output=output,
        tick_interval=tick_interval,
        backbone_thickness=backbone_thickness,
        mismatch_line_width=mismatch_line_width,
        gap_label_size=gap_label_size,
        query_annotations=query_annotations,
        reference_annotations=reference_annotations,
        annotation_label_size=annotation_label_size,
        annotation_thickness=annotation_thickness,
        annotation_alpha=annotation_alpha,
        reference_annotation_color=reference_annotation_color,
        query_annotation_color=query_annotation_color,
        annotation_label_jitter=annotation_label_jitter,
        annotation_max_layers=annotation_max_layers,
        annotation_spacing=annotation_spacing,
        x_window=x_window,
        inversion_regions=inversion_regions,
        feature_regions=feature_regions,
        return_metadata=return_metadata,
        tight_bbox=tight_bbox,
        full_canvas_axes=full_canvas_axes,
    )


def render_bytes(
    *,
    fmt: str,
    data,
    global_x,
    query_x,
    reference_x,
    query_positions,
    reference_positions,
    global_extent: float,
    gap_labels,
    width: float,
    height: float,
    dpi: int,
    tick_interval: int,
    backbone_thickness: float,
    mismatch_line_width: float,
    gap_label_size,
    query_annotations,
    reference_annotations,
    annotation_label_size,
    annotation_thickness: float,
    annotation_alpha: float,
    reference_annotation_color: str,
    query_annotation_color: str,
    annotation_label_jitter: float,
    annotation_max_layers: int,
    annotation_spacing: float,
    x_window: Optional[Tuple[float, float]] = None,
    inversion_regions: Optional[Sequence[dict]] = None,
    feature_regions: Optional[Sequence[dict]] = None,
) -> bytes:
    suffix = ".svg" if fmt == "svg" else ".png"
    with NamedTemporaryFile(suffix=suffix, delete=True) as handle:
        plot_alignment(
            data,
            global_x,
            query_x,
            reference_x,
            query_positions,
            reference_positions,
            global_extent,
            gap_labels,
            width,
            height,
            dpi,
            Path(handle.name),
            tick_interval,
            backbone_thickness,
            mismatch_line_width,
            gap_label_size,
            query_annotations,
            reference_annotations,
            annotation_label_size,
            annotation_thickness,
            annotation_alpha,
            reference_annotation_color,
            query_annotation_color,
            annotation_label_jitter,
            annotation_max_layers,
            annotation_spacing,
            x_window,
            inversion_regions,
            feature_regions,
        )
        handle.seek(0)
        return handle.read()


def render_svg_with_metadata(
    *,
    data,
    global_x,
    query_x,
    reference_x,
    query_positions,
    reference_positions,
    global_extent: float,
    gap_labels,
    width: float,
    height: float,
    dpi: int,
    tick_interval: int,
    backbone_thickness: float,
    mismatch_line_width: float,
    gap_label_size,
    query_annotations,
    reference_annotations,
    annotation_label_size,
    annotation_thickness: float,
    annotation_alpha: float,
    reference_annotation_color: str,
    query_annotation_color: str,
    annotation_label_jitter: float,
    annotation_max_layers: int,
    annotation_spacing: float,
    inversion_regions: Optional[Sequence[dict]] = None,
    feature_regions: Optional[Sequence[dict]] = None,
) -> tuple[bytes, dict]:
    with NamedTemporaryFile(suffix=".svg", delete=True) as handle:
        metadata = plot_alignment(
            data,
            global_x,
            query_x,
            reference_x,
            query_positions,
            reference_positions,
            global_extent,
            gap_labels,
            width,
            height,
            dpi,
            Path(handle.name),
            tick_interval,
            backbone_thickness,
            mismatch_line_width,
            gap_label_size,
            query_annotations,
            reference_annotations,
            annotation_label_size,
            annotation_thickness,
            annotation_alpha,
            reference_annotation_color,
            query_annotation_color,
            annotation_label_jitter,
            annotation_max_layers,
            annotation_spacing,
            None,
            inversion_regions,
            feature_regions,
            return_metadata=True,
            tight_bbox=False,
            full_canvas_axes=True,
        )
        handle.seek(0)
        return handle.read(), metadata or {}
